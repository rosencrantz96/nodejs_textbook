# Node.js란?

Chrome V8 Javascript 엔진으로 빌드된 **자바스크립트 런타임**

☹️ 서버라는 말이 없는데요?!

→ 노드가 서버만 실행할 수 있는 것이 아니기 때문!

→ 노드를 통해서 다양한 자바스크립트 애플리케이션을 실행할 수 있는데, 노드는 서버 애플리케이션을 실행하는 데 제일 많이 사용한다

## 01 서버

> 서버란? <br>
> : 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램

클라이언트는 요청을 보내는 주체 → 브라우저일 수도, 데스크톱 프로그램일 수도, 모바일 앱일 수도 이쏙, 다른 서버에 요청을 보내는 서버일 수도 있다

<img src='./img/클라이언트와 서버.png'>

### Ex 1. 웹사이트 방문

-  주소창에 웹 사이트 주소 입력(**요청**)
-  브라우저는 그 주소에 해당하는 사이트의 컴퓨터 위치를 파악
-  컴퓨터로부터 해당 주소의 웹 사이트 페이지를 받아와서 요청자의 브라우저(클라이언트)에 띄운다(**응답**)

→ 이런 일을 하는 컴퓨터가 바로 **서버**인 것이다

### Ex 2. 모바일 앱 설치

-  구글 플레이 스토어나 애플 앱스토어에서 원하는 앱을 고른 후 설치 버튼을 누른다(**요청**)
-  내려받기 시작(**응답**)

→ 앱 설치 파일은 <u>이미 어딘가(**구글과 애플의 서버**)에 저장</u>되어 있음

→ 그 곳에서 데이터를 받아와 모바일 기기에 설치

→ 플레이 스토어와 앱 스토어 = 클라이언트 역할

### 서버는 클라이언트의 요청에 응답을 하는 역할

## 02 자바스크립트 런타임

$*$ 런타임 : 특정 언어로 만든 프로그램들을 실행할 수 있는 환경

→ 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있다 (자바스크립트 실행기)

-  기존에는 자바스크립트 프로그램을 웹 브라우저 위에서만 실행할 수 있었다 (브라우저는 자바스크립트 런타임을 내장하고 있어서 자바스크립트 코드를 실행할 수 있었다) : 브라우저 외의 환경에서는 자바스크립트의 실행 속도 문제 때문에 시도는 있었으나 잘 사용되지 않음

-  2008년 구글이 V8 엔진을 사용해 크롬을 출시 → 다른 자바스크립트 엔진과 달리 매우 빨라서 속도 문제 해결 → (라이언 달) 2009년 V8 엔진 기반의 노드 프로젝트 시작

> 노드 = V8 + libuv라는 라이브러리 사용

V8, libuv는 C와 C++로 구현되어 있다 → 노드가 알아서 V8과 libuv에 연결해주기 때문에 C, C++은 몰라도 됨

$*$ libuv 라이브러리 → 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델 구현

## 03 이벤트 기반

> 이벤트 기반(event-driven) : 이벤트가 발생할 때 미리 지정해 둔 작업을 수행하는 방식

→ 특정 이벤트가 발생할 때 무엇을 할 지 미리 등록해둬야 한다 = **이벤트 리스너(event listener)에 콜백(callback)함수를 등록한다**

노드도 이벤트 기반 방식으로 동작 : 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수 호출, 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 노드는 다음 이벤트가 발생할 때까지 대기한다

### ⭐ **이벤트 루프(event loop)**

여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단
→ 노드는 자바스크립트 코드의 맨 위부터 한 줄씩 실행한다

```javascript
function first() {
   second();
   console.log('첫 번째');
}
function second() {
   third();
   console.log('두 번째');
}
function third() {
   console.log('세 번째');
}
first();
```

이렇게 실행하면 가장 먼저 first 함수가 호출되고, 그 안의 second 함수가 호출된 뒤, 마지막으로 third 함수가 호출된다

그리고 호출된 순서와는 반대로 실행이 완료된다

호출 스택을 그려보면 이해가 쉬운데 (안쉬움)

<img src='./img/호출 스택.png'>

anonymous 함수는 처음 실행 시의 전역 콘텍스트(global context)를 의미한다 → 콘텍스트는 함수가 호출되었을 때 생성되는 환경 (자바스크립트 코드는 실행 시 기본적으로 전역 콘텍스트 안에서 돌아간다고 생각하는 것이 좋다고 함)

함수는 실행되는 동안 호출 스택에 머물러 있다가 실행이 완료되면 호출 스택에서 지워진다

third, second, first, anonymous 순으로 지워지고, anonymous 콘텍스트까지 실행이 모두 완료되었다면 호출 스택은 비워 있게 된다

따라서 콘솔 창에는

```console
세 번째
두 번째
첫 번째
```

출력 결과가 이렇게 찍힌다

특정 밀리초(1,000분의 1초) 이후에 코드를 실행하는 setTimeout을 사용하면 콘솔에 어떻게 찍힐까?

```javascript
function run() {
   console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```

3초 뒤에 run 함수를 실행하기 때문에 콘솔 결과는 이렇게 찍히게 된다.

```console
시작
끝
3초 후 실행
```

콘솔 결과는 예측이 쉽지만 호출 스택으로 설명하긴 어렵다. run이 언제 호출 스택에 들어가는지 지금까지 배운 내용으로는 알기 어렵기 때문이다.

> $*$ **이벤트 루프** : 이벤트 발생 시 호출할 콜백 함수들을 관리, 호출된 콜백 함수의 실행 순서를 결정하는 역할 <br>
> → 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하기 때문에 루프(loop)라고 부른다

> $*$ **백그라운드** : setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳 <br>
> → 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 무방, 여러 작업이 동시에 실행될 수 있다

> $*$ **태스크 큐** : 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다 <br>
> → 정해진 순서대로 콜백들이 줄을 서 있어서 콜백 큐라고도 한다 (보통은 완료된 순서대로 줄을 서 있지만 특정한 경우 순서가 바뀌기도 한다)

setTimeout 함수가 실행되는 내부 과정은 이렇다

<img src='./img/이벤트 루프 1.png'>

-  전역 콘텍스트인 anonymous가 호출 스택에 들어간다 그 뒤 setTimeout이 호출 스택에 들어간다

-  호출 스택에 들어간 순서와 반대로 실행되므로 setTimeout이 먼저 실행된다

-  setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고, setTimeout은 호출 스택에서 빠진다

-  그 다음으로 anonymous가 호출 스택에서 빠진다

-  백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보낸다 (3초를 센다 = 백그라운드에 맡겨진 작업이 완료되었다)

-  그림으로는 태스크 큐가 하나의 큐처럼 보이지만 실제로는 여러 개의 큐로 이뤄져 있다

-  이벤트 루프는 정해진 규칙에 따라 콜백 함수들을 호출 스택으로 부른다

<img src='./img/이벤트 루프 2.png'>

-  호출 스택에서 anonymous까지 실행이 완료되어 호출 스택이 비어있다

-  이벤트 루프는 호출 스택이 비어 있으면 태스크 큐에서 하나씩 함수를 가져와 호출 스택에 넣고 실행한다

-  호출 스택으로 올려진 run은 실행되고, 실행 완료 후 호출 스택에서 제거된다

-  이벤트 루프는 태스크 큐에 콜백 함수가 들어올 때까지 계속 대기한다

> $*$ setTimeout의 시간이 정확하지 않을 수도 있다?!
> : 만약에 호출 스택에 함수가 너무 많이 들어 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수도 있다 → **이벤트 루프는 호출 스택이 비어 있을 때만** 태스크 큐에 있는 run 함수를 호출 스택으로 가져오기 때문

## 04 논블로킹 I/0

기본적으로 자바스크립트 코드는 동시에 실행될 수 없다

하지만 자바스크립트 상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있다!

> I/O : 입력(Input)/출력(Output)

파일 시스템 접근(파일 읽기 및 쓰기, 폴더만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종

이러한 작업을 할 때 노드는 논블로킹 방식으로 처리하는 방식을 제공한다

> 논블로킹(non-blocking) : 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것<br>
> 블로킹(blocking) : 이전 작업이 끝나야만 다음 작업을 수행하는 것

➡️ 블로킹 방식보다 논블로킹 방식이 같은 작업을 더 짧은 시간 안에 처리한다 하지만 **작업들이 모두 동시에 처리될 수 있는 작업이라는 전제**가 있다

☑️ 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리한다 → 동시에 처리될 수 있는 작업들은 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다

작업 순서에 따라 큰 성능 차이가 난다! 동시에 처리될 수 있는 I/O 작업이더라도 논블로킹 방식으로 코딩하지 않으면 의미가 퇴색되므로 <U>논블로킹 방식으로 코딩</U>하는 습관을 들여야 한다

```javascript
function longRunningTask() {
   // 오래 걸리는 작업
   console.log('작업 끝');
}

console.log('시작');
longRunningTask();
console.log('다음 작업');
```

다음과 같은 블로킹 방식의 코드는

```console
시작
작업 끝
다음 작업
```

콘솔에 이런 결과가 찍힌다.

이 함수가 블로킹 방식의 I/O 작업을 한다면 이 작업이 완료되기 전까지는 이어지는 `console.log('다음 작업')`이 호출되지 않는다.

```javascript
function longRunningTask() {
   // 오래 걸리는 작업
   console.log('작업 끝');
}
console.log('시작');
setTimeout(longRunningTask, 0);
console.log('다음 작업');
```

이렇게 코드를 수정하면

```console
시작
다음 작업
작업 끝
```

결과 창엔 위와 같이 찍힌다.

`setTimeout(콜백, 0)`은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나

다만 아무리 논블로킹 방식으로 코드를 작성하더라도 코드가 전부 내가 작성한 것이라면 전체 소요 시간이 짧아지진 않는다 **코드는 서로 동시에 실행되지 않기 때문이다** ➡️ 단순히 실행 순서만 바뀔 뿐

하지만 I/O 작업이 없다고 해서 논블로킹이 의미가 없는 것은 아니다! 오래 걸리는 작업을 처리해야 하는 경우 논블로킹을 통해 실행 순서를 바꿔줌으로써 그 작업 때문에 간단한 작업들이 대기하는 상황을 막을 수 있다는 점에서 의의가 있다

> **논블로킹**과 **동시**는 같은 의미가 아니다
> ➡️ 동시성 : 동시 처리가 가능한 작업을 논블로킹 처리해야 얻을 수 있는 것

## 05 싱글 스레드

> 싱글 스레드 : 스레드가 하나

스레드를 이해하기 위해서는 프로세스부터 알아야 한다

<img src='./스레드와 프로세스.png'>

> $*$ 프로세스 : 운영체제에서 할당하는 작업의 단위 → 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스, 프로세스 간에는 메모리 등의 자원을 공유하지 않는다 <br> > $*$ 스레드 : 프로세스 내에서 실행되는 흐름의 단위 → 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있고, 스레드들은 부모 프로세스의 자원을 공유한다 (같은 주소의 메모리에 접근이 가능하므로 데이터를 공유할 수도 있다)

### ☑️ 노드는 싱글 스레드이다

→ 엄밀히 말하면 싱글 스레드로 동작하지는 않는다

-  노드 실행
-  프로세스가 하나 생성
-  그 프로세스에서 스레드들을 생성 → 이 때 내부적으로 스레드를 여러 개 생성한다
-  그 중 내가 직접 제어할 수 있는 스레드는 하나 뿐 = 싱글 스레드로 여겨진다

### ✅ 싱글 스레드, 블로킹

<img src='./img/싱글 스레드 블로킹.png'> <br>
점원이 한 명 있고 손님은 여러 명, 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙을 하고, 그 후 다음 손님의 주문을 받는다

이러한 구조에서는 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 하지 못하고 기다리고 있어야 한다 (매우 비효율)

### ✅ 싱글 스레드, 논블로킹

<img src='./img/싱글 스레드 논블로킹.png'> <br>
점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다, 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 것을 주방에 계속 알려준다, 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다, 요리의 특성(블로킹/논블로킹)에 따라 완료되는 순서가 다를 수 있으므로 주문이 들어온 순서와 서빙하는 순서가 일치하지 않을 수 있다

이것이 바로 노드가 채택하고 있는 방식이다 → 점원이 한 명이지만 혼자서 많은 일을 처리할 수 있다

하지만 점원이 아프거나 요리를 하는데 시간이 오래 걸린다면 (CPU를 많이 쓰는 작업) 주문이 많이 들어왔을 때 버거울 수 있따

### ✅ 멀티 스레드, 블로킹

<img src='./img/멀티 스레드 블로킹.png'> <br>
손님이 한 명 올 때마다 점원도 한 명씩 붙어 주문을 받고 서빙한다

장점 - 손님 한 명당 점원도 한 명이기 때문에 서빙 자체는 걱정이 없다 <br>
단점 - 손님의 수가 늘어날 수록 점원의 수도 늘어난다, 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다, 점원을 새로 고용하거나 기존 직원을 해고하는데 비용이 발생한다

☹️ 그럼 점원 여러 명(멀티 스레드)이 논블로킹 방식으로 주문을 받으면 더 좋은 거 아닐까? <br>
: 그렇다... 다만 멀티 스레드 방식으로 프로그래밍 하는 것은 어렵기 때문에 멀티 프로싱 방식을 대신 사용한다 (I/O 요청에는 멀티 프로세싱이 더 효율적)

| 멀티 스레딩                                  | 멀티 프로세싱           |
| -------------------------------------------- | ----------------------- |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용 |
| CPU 작업이 많이 사용될 때 사용               | I/O 요청이 많을 때 사용 |
| 프로그래밍이 어려움                          | 비교적 쉬움             |

➡️ I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이기 때문에 노드는 멀티 프로세싱을 많이 한다
